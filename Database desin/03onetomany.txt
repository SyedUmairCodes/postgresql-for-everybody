# Relational Database Design Part 1
Hello and welcome to Relational Database Design. This is a really interesting topic and it's a topic that I think you can learn pretty quickly. But it's sort of like the artistry of what databases are. And so what I'm going to be teaching you is kind of techniques. And I'm going to assume that at some level you're going to not think that you're a great database designer and you're going to get better the more you do it. And it also really helps to do it with other people. I know that when I learned to do database design, I did it with a group of people and I was in a conference room and we had a whiteboard and we were drawing pictures. And people who knew more than me were drawing pictures. And I was able to get it by drawing pictures. So I'm going to simulate that in this lecture. But at some point, for you to get really good, you're going to have to work with people who know more than you, who can mentor you, and then it comes to you pretty fast. So the basic idea of database design is you're going to end up drawing a picture of the shape of data. And so you're going to end up with something that looks like this picture. This is a picture from a database for software that I write, that I use for learning technology that I build for autograders for classes, etc. And this happens to be a database that's thinking about students, it's thinking about courses, it's thinking about memberships in those courses, it's thinking about roles, it's thinking about different courses. And so eventually I have to draw this picture. And so we're going to try to get you to draw pictures, and they have lines between them. And each of these boxes on the picture is a table and the lines are what are called foreign keys. We'll cover all this in a bit. But you end up drawing a picture of your data and then you translate that picture into a set of database commands and shapes to create it. And if you go into a large project, Sakai is another project that I am part of, and this is just a small part of it. You will often notice that the project has like a data model on the wall in a giant five-feet-by-three-feet diagram. And that's because this becomes kind of like the core essence, the soul of an application is the data model, the way you store the data. And so it's very, very important. So the idea is in building a data model, is that you can't always just read through a file in sequence. You want to be able to sort of bounce around in that file. And in a way, it's a form of compression through connection, if that makes any sense. And so if you have an email address, csev@umich.edu, and you're going to have all kinds of places in the data of this application where something is owned by csev@umich.edu, the basic rule is, and this is a form of compression, is you don't put that string in your database more than once. You put that string in once and then give it a key, like a number. And so if you were using this on Coursera, for example, you might find that when I logged into Coursera for the very first time, I was assigned a user number, like 116,421. And instead of putting my email address throughout the Coursera data model, they just put that number. And so we need this number and if I author a discussion forum post, we use the number to indicate that I was the author of that. If you comment it, we use your number, we don't use your email address. If all goes well, we should have one table and one field and one copy of your email address in a database. And so one way to think about this, and this is the way that I first learned how to do this, is you take an application and you have to build a data model from a mock-up of the user interface to the application. And so you can kind of imagine you're at a startup. I was building an educational system for Ford Motor Company when I first learned to do data modeling many years ago. And so we knew what the designers thought they needed in terms of this is the user interface. And then we have to come up with a database. Now you might think, well, I'll just make this a CSV file, it doesn't look like it's all that much data. The problem is that if you just make it a CSV file for 100 entries, it might be fast and for 300 entries it might be fast. And then for 3 million entries, it's not fast. And then for 300 million entries, it's not fast. And the interesting thing about databases is you can have 300 million entries and it still can be fast. And the basic flaw in a CSV file, and I don't know if you've ever tried, you probably haven't. But a lot of people have tried to like make a spreadsheet of all of your music. And it's easy to type this stuff in but you end up with what I'll call vertical replication. So when you're typing these things in, you type in a track and then you type in the artist and the album and the genre. And then you type in another track and then you copy and paste these pieces. And you copy paste, copy paste, copy paste, copy paste. And that seems like it's okay, but if you start thinking about this, it's kind of frustrating. You still need to know that these are part of an album and part of an artist and part of a genre, you still need to know that. But then let's just say you want to go in and edit it. And let's just say that as you were putting this in, you had a typo. And you have many albums by Black Sabbath. But you made a typo and you kept copying and pasting, and now you've got to go fix it, fix it everywhere. In this simple one, it seems simple enough. But if we're talking millions and millions of records, then it's impossible. And that's why ultimately we want to come up with a data model where the word Black Sabbath ends up in one table one time, and then there's some number, 42 for example. And then everywhere we want to mark something as belonging to Black Sabbath instead of, there we go, instead of putting in Black Sabbath, we put in 42, 42, 42, 42, 42, dot, dot, dot, dot, dot. And now if I made a typo, and so this somewhere else in some other table is Black Sabbath and 42 is the number, and I made a typo, I just fix it here, and somehow, magically, all this changes.
Play video starting at :6:44 and follow transcript6:44
So you could go get a whole PhD in database. What I just described is the single most important concept in building a data model. And I'll say this over and over. Vertical replication of string data is not what we want to do. Now, the thing we don't want to do is go back to our user interface designers and say, you know what? Do you realize how bad vertical replication of data is? Because I took a class and my professor said I shouldn't do vertical replication of data. So you need to make a new user interface. And that's wrong. The interface should be what it is. If this is the interface, and now we can see all this, because this is pretty convenient, as a user I kind of like this, right? I can sort these things up and down and up and down, and I do want to see this, and I want to be able to search for Black Sabbath, I want to search for all these words, and I want to see all this vertical replication in the user interface. I just don't want to have it in the database for efficiency purposes. So we accept the user interface and its needs as okay. We don't fight that. But what we have to do then is make a data model and then reconstruct from that data model the user interface that they want. So the idea is that you find sort of each string, number, each piece of data, and then you decide which table you're going to put it in. And sometimes you have to build new tables and then you build these tables and then you draw lines in between the tables. And you end up with those pictures that I talked about before. So we'll stop here, but then when we come back, we're going to go through and build such a table.

# So like I said, we're not going to argue with the design of the user interface, even though it has this vertical replication of data. What we're going to do is we're going to come up with a way to spread this data across multiple tables so that we end up with no replication of the data in the tables that we produce. So what we're going to do is we're going to go through these columns and we are going to basically decide is this column part of an existing object or a new object? And so once we have an object, we'll add stuff to it. So it's like what are the things and what are attributes of things? And so this is the set of columns. Now, the interesting thing is that the first thing that you got to do is you got to figure out what your first object is. And again, I talked about how you're often in a room and there are people who go through this process that have a good instinct about this. And in a lot of applications, the simple answer is the user. So if you think of a multi-user system, often the user, and you tend to draw that first table or that first object in the middle so that everything else connects to it. But in this situation, this is a single-user application, so we can't just say, oh the user is kind of the core thing. So you ask yourself, what is the single thing that this application is organizing? And this is a music system that tracks the tracks we own, and plays tracks, and keeps track of tracks that are parts of albums, and which albums belong to which, etc., etc. How many times we play the track, and after a while you figure out, oh maybe, maybe, just maybe, the track is the first thing that we should work with. So let's basically make a table that has tracks.
Play video starting at :2: and follow transcript2:00
Now, we kind of got that column configured out. Now we've got a table of tracks. So we can look across and there's certainly like the title of the track. So we'll put the title in here. So we've got the title, so the track has a title. And then another thing that is pretty easy is numbers are no big deal, right? We don't worry about vertical replication of numbers. The fact that we have things that are both rated fours, numbers are cheap. So we'll just right away stick the length, we're going to stick the genre, and we're going to stick the number of plays, and the length, and the genre, and we're just going to put those in the track. And so we've sort of got this taken care of, we've got this taken care of, and we've got this taken care of and that taken care of. They're just all attributes of track, like length. Those are just attributes. So we've kind of got length, we got the count, we got the rating, and then we got the track and that's taken care of in that track title. So we got one table. Now, it's not random that the columns that have the string vertical replication are like there are the ones that we don't have. And so we'll basically say, okay, what other things do we have? Well, we have an album, right?
Play video starting at :3:18 and follow transcript3:18
And so this is the album and all tracks belong to albums. It's a little less of a mess if you're doing this in a whiteboard in an office, but you get the idea. So tracks belong to albums and albums, well, albums you can't just put the artist's name in here because there could be many albums to one artist. And so you have an artist out here and albums belong to artists. Right? So tracks belong to albums and albums belong to artists. So we've got this done and we've got that done. So the only column we have left is the genre. Now, the genre, let's see if we can get a different color here. Yeah, we could actually take the genre and we could connect it to the artist, we could connect it to the album, or we could connect it to the track. And this is a situation where actually the decision that we're going to make here is going to change how this will work. So if we connect it to the track, you change this to a new thing and it won't affect any of the other tracks. But if you connect it to the album, use this connection, the connection to the album, if you change it in this album of Who Made Who, and you change Rock, the genre of Who Made Who, then all these are going to change at the exact same moment. Right? And if you connect genre to the artist, all the AC/DCs, I have many of them, of course. If you change the genre of AC/DC, then all the genres of all the AC/DC tracks are going to change at the same time. And so you can sit there and you can argue, is the genre an attribute of artist? Is it an attribute of album? Or is it an attribute of track? And the right answer in this one probably is track. And so you basically decide that you're going to connect genre to track and away you go. And you end up with a picture that looks like that. Isn't it amazing how much nicer this picture looks than my scribblings? So you have track, you have rating, you have length and count that are attributes of track. They're just numbers, they're cheap. There's a title in track and that's probably what's missing with this. There's a title here. This probably should be the track table with a title in it. Genre belongs to track. There is one genre and many tracks have one genre. Many tracks connect to one album and many albums connect to an artist. And so this is a way to basically make it so that you'll, again, also notice that all the vertical representation, things that have vertical replication ended up with their own table and things that are just numbers and are otherwise not vertically replicated ended up as attributes in a table. And so that's our data model. Now, you probably are thinking to yourself, well, that's not the most perfect data model, and the answer is, yes. We're going to simplify for now. Some of these things about which artist belongs on which album. An artist might not always be a group. It might be a set of individuals, but let's ignore that for now. But that's the cool part of data models. At some point you might want to actually just build a really good music data model that doesn't have so many of these that is not quite as simple as this one. But for now, we're going to work on the mechanics of this and we're going to assume that this is a good data model for which to model music. Up next, we're going to talk about how we build keys and add keys to these tables so that we can make the connections in between tables.

# Keys
So now we're going to talk about the different kinds of keys, and what keys are is kind of connection points. We connect one row to another using a key, or we will go find a row in a database table using a key. And there are three kinds of keys. So each row in a table gets what we call a primary key, and that's like to give us a handle to say that row. So that's like the AC/DC row is number 42. The Led Zeppelin row is number 75. csev@umich is number 120,453. Those are the primary keys, and that's that single string. And then this number is what we're going to replicate all over the place. So that's a primary key. Then there is, in most tables, what we call a logical key. And the primary key is not something. It might show up in URLs in your user interface or something. But the primary key is almost never something that you know what your primary key is, whereas the logical key is that's you, right? And so that is your email address, or the title of the track, or the title of the album, or the email address of the logged-in user, or something like that. So if you think of the outside world saying I've got to go find a particular person, or track, or whatever, they use the logical key. Or if it was in a user interface, and there was a search button, the thing you type into the search, that's the logical key, that's the thing that the world uses to find a row.
Play video starting at :1:34 and follow transcript1:34
And then the other thing that's sort of internal to the database is what's called the foreign key. And that is an integer in one table that points to a row in a different table. And that's why we call it a foreign key, that far away table is the "foreign" table, this is the local table. And we have a naming convention and different organizations and different pieces of software will use different naming conventions. And so I've just chosen one of the more common naming conventions, where in every table, in this case, the album table, the id field is going to be the primary key. And so we'll just know that no matter what we name our table, we're going to name the primary key field id. Logical key will be whatever, and we use a convention of foreign keys end in underscore id, and the first part is the name of the table. So I can look because of my convention that artist_id points to a row in the artist table. And when you go to an organization, an important part of database is a set of rules and conventions that an organization uses to keep themselves sane. And so you will go in, and they'll say okay, this is how we name our fields. And you're like, oh, wait, I was in college, and my professor named fields a different way. Don't say that. Just say oh, that's great, I really like working here. And then follow their rules, because ultimately, which set of rules you pick doesn't matter as much as being consistent within those rules. So I've picked a pretty common set of rules, and you'll go a lot of places, and you'll see the same rules that I've picked. But just because an organization uses a different set of database naming rules database column naming rules doesn't mean that they're wrong, per se. So the primary key is a somewhat counter-intuitive notion for a lot of people. You think to yourself, well, your email address is your email address, and why you wouldn't you use that everywhere? And there are some database experts that might even tell you that's a good idea, but it's not a good idea, those databases experts are wrong. The key thing is that the whole thing that makes this super fast, no matter what database system you're using, is this mapping from a string to a number. And those people that would suggest that you could use a logical key as a primary key, meaning that you could put an email address everywhere, what they're really doing is using a database layer to kind of fake it, to fake that. And there's still a number, it's just a number you're not dealing with. So you might as well go ahead and deal with the number. And things like email addresses change. Here at the University of Michigan, you can come, and you can get an account, and you can get married, or divorced, or just not like your name. Because we make something up with a bit of your first name and a bit of your last name, and they don't all come out great, right? So you fill out a form, and you can change your logical key. But on the systems we have on campus, once you've started registering for classes, we can change your logical key. And remember, it's a string, if the system is properly architected, it's exactly one place. Now, at the university, you might have like 20 large systems. So if we change your email address, we've got to get ahold of all 20 systems, and say this person's email address on this day is changing from this to this. And then the 20 systems all change it, but within those systems, they have one place to change it. They change the logical key in the one table that is the user table, or whatever. And so be careful about believing too much about email addresses not changing, even though on average, they do change very slowly. And so if you're using as primary key like a string rather than a number, and people also use these things called GUIDs. Which are long strings of random numbers, and then join on GUIDs, those things are not as efficient, although in some databases, they kind of fake the efficiency. And so the simple thing is just use integers as your foreign keys, integers as your primary keys, and strings or whatever as your logical keys. And then no matter what database you're using, you're going to run very effectively. And like I said, a foreign key is a key that points to the primary key of another table. And so if we are pointing to a row in the artist table, we would name that artist_id. And again, I'll just say one last time, when the primary keys are integers, then foreign keys are integers, and matching them is something that systems can do very efficiently. So up next, we're going to start using these foreign keys and these primary keys as connecting together using what we call database normalization. We're going to like bring all of this together, and actually start kind of writing code.

# Database Normalization
So now that you know about primary keys, logical keys, and foreign keys, let's start using them. So remember our goal was to be able to keep track of all this stuff. And so we're going to have a track table, a artist table, an album table, and a genre table. And we're going to get these little numbers. And then we're going to use these numbers to keep track of all this stuff. Because we're going to have to then reconstruct it from those numbers to create the vertical replication of the string data in the user interface just like our designer asked us to do. So you literally could spend months reading the concept of database normalization. Feel free, okay? I took a database class when I was in grad school and it just went totally over my head and I thought databases are a dumb idea. There's way too much complicated theory here. And then I went to work in a company and I sat in a room and by the noon on one day I'm like, I love databases. And that's because they taught me how you really do it rather than the theory. And I'm not saying theory's bad. Theory's awesome. That's why they're so fast. But from a technique perspective, it's pretty straightforward. First, don't replicate string data. Reference the data, point at data. It's a form of compression. Then use integer keys for your primary keys and for your references and put that primary key in each column, which we talked about already. So rows end up in these columns. And so when we're going to put AC/DC or Led Zeppelin in, we just say, okay, here's Led Zeppelin. And Led Zeppelin for all intents and purposes everywhere else in the system is going to be stored in a column called artist_id. And then that number goes in there. So Led Zeppelin is 1. AC/DC is 2. And once you insert them for pretty much the life of the system, although you can change them later if you really want. In general you will just use 2 to indicate AC/DC and 1 to indicate Led Zeppelin from that point forward in these foreign key columns. Now, you can have many sort of one primary key and you can have many foreign keys pointing to it. It's just in our data model, it's pretty simple. So each of these little arrows that we drew just kind of scribbling on the board becomes sort of this pair of numbers, a source number and a destination number or a parent and child is another way to think about it. So so we take this logical schema that we built of what belongs to what, which we just were talking and brainstorming and getting our data spread into more than one table. And now we're going to actually reconnect them together. And so we ended up with this picture that had these albums belonging to. And this was just a logical data model. And it doesn't even have to look all this elegant, but you have to take this data and split it into some number of tables, in our case four. And now we're going to show about the mechanics of making all these connections. And so it's pretty simple. You've got this arrow and we have to have a way in the arrow. There's no like in a database we say it's an arrow. They need columns. We need to have a column in there and that column is an integer. So we add the columns. So we augment the primary key and we add a primary key field to each one of the tables and then we have a logical key. And the logical key is just another column except we distinguish it. We just put a little asterisk by it. Say this is special. This is the one we're going to use when we have many rows to look up a particular row. Once we get to that row we'll find things like the rating, length, and count, right? And so the database by us telling that the title of the track is going to be something we're going to look up on, the database actually does stuff in how it represents the data by building what are called indexes to make it more efficient to look those things up, right? We talked about those indexes before. And so the logical key simply says something that we would like you to make an index for because we're going to use it a lot. And the faster you're capable of responding to lookups by title because we're not going to spend all that time looking it up by rating. We might sort by rating or whatever. But the thing we're going to look up and we expect to be really fast is the logical key. So logically it's just a column. It's a string column, a VARCHAR or whatever column. And these are just integer columns. But then to model the picture and this is what's called a many-to-one relationship, many-to-one. And there are many tracks that are on one album and it's like another way to think about this is it's somewhere between zero and infinite number of tracks per album. So that's also a way to think about the many side of this arrow and so on the one side of the arrow, we just put in this primary key and on the many side, we add a column. And we call it album_id where the first part of that is the name of the table and the second part of that is our little memory technique to realize oh, that's a foreign key and it's in the album table. And so that's how we sort of in an abstract way draw arrows. So we take and we map these arrows and we turn them into columns. So it's a pretty mechanical process. Literally once you got it figured out, pick the logical key, add the primary key, and add any necessary foreign keys based on the arrows that you've got. And so when you finish this over and over and over again, we had four tables. We had three arrows. And so we end up with one, two, three, four primary keys. We end up with a logical key in each table. And then we had three arrows so we end up with three starting points. And then we put foreign keys at the starting points of those arrows. And away we go. And so once you have the picture you're kind of like follow the technique. I can write these things super fast and then I can read them. They're really pretty. And again, I go back to the fact that I've used a convention to build all this stuff. And I can look at this like, yeah, of course, that's a foreign key. And it won't take you long and you'll start seeing the exact same thing that these are foreign keys. So now that we've sort of built the structure, now we're going to start typing some SQL commands so that we can insert create these tables with these special fields and then start inserting some normalized data.

# Building Tables
So now that we've come up with a way that we augment our logical model to make a physical data model, it's time to do some SQL, and actually create these tables, and put them together. Now, if you're going to, you might have to create a whole new database, and you do this with the superuser. Depending on how we're having you do assignments, there might be slightly different instructions for this. But basically, we're going to create a database. And the pg4e account that we made before has a password, and so we'll create that. But you might get slightly different instructions on your assignments. But at some point, we've got to make a database. And you'll always notice that in this thing I'm running as the superuser, the superuser is both the Postgres user. And then that's the one that creates database. And pg4e, that is a user who's not so super. So once you have that database, the music database, we'll make a connection to that database, and then we'll start typing SQL commands. And so you've been doing create tables before, so you sort of know various things here. You're going to create a table, and then there's a series of columns that are in that table. So the first thing we have is Postgres has a really nice way of indicating the column that's going to be the primary key. And so it has this extension, so that's not in all databases. The SERIAL is a thing that basically communicates. I want a column named id, and I want it to be the primary key. Make it a number, give it to me automatically, incement it. It's a number that starts at 1, 2, 3, 4, 5, 6, 7. And this also then added to that is PRIMARY KEY, tells the database that we're going to be looking these things up fast. And please make me an index on this, a very fast index. And then the logical key, we just add this word UNIQUE. And so what UNIQUE basically is saying is that we're only going to allow one particular name, so AC/DC can only have one row. So if you try to insert a row with AC/DC, the first one will work, and the second one will blow up if it's still AC/DC. And so that's also a way to communicate that there's supposed to be an index on this field, because the database has to index that field so that when it is inserting the next AC/DC, it can quickly decide whether or not AC/DC is already there. But the very thing that lets it figure out that AC/DC's already there makes it so it's pretty easy to look up AC/DC, so it has a quick way to find the row that belongs to AC/DC, okay? And so these two lines here are going to be our pattern, the SERIAL and PRIMARY KEY are our pattern for the primary key. And UNIQUE will be our basic pattern for string-based logical keys.
Play video starting at :2:41 and follow transcript2:41
So if we look at the album table, we see that we've got a primary key using that same pattern. This is what you want. Once you've got these, you just like copy paste, copy paste, and change a few things, right? And then we add the UNIQUE oh, there's a typo there. Don't worry about that, that should be UNIQUE right there.
Play video starting at :2:58 and follow transcript2:58
And so we have a title, which is our logical key. We say UNIQUE, which communicates. And then we're putting in our first foreign key. And remember, foreign key is the thing that points from one to the other. The foreign key is at the beginning of the arrow. So artist_id is a column. It's an integer, REFERENCES says this references the the id field in the artist table, and then ON DELETE CASCADE. So ON DELETE CASCADE is a way that basically says if we have an artist table and an album table, and there's a bunch of rows in the album table, and they all point to one of the artists, if we delete the artist, then all the rows go away. And that's because it knows we deleted one of these artists, it goes and finds all of the corresponding album entries and deletes them. So we cascade a delete from the artist table into the album table, and that's what ON DELETE CASCADE means. Okay, so the genre table, if you remember the picture of the genre table, the genre table just is something we're going to point at. So in a many-to-one, this is a one. And so it just has a primary key, and it has a unique logical key that is the name of the genre. And the track is is actually, it looks complex, but it's really not that complex. We have a primary key, we know how to do one of those things. You make it serial, and then indicate PRIMARY KEY down here. We make a logical key, but we're going to do this one a little bit different, I'll show you in a sec. These are just columns. Length, rating, and count are just columns. And there are two foreign keys, because if you remember in the track table, they point to an album table, and it points to the genre table. And so we have a pointer album_id points to ON DELETE CASCADE, so that looks like normal foreign keys. And then the cool part about this one is the UNIQUE. Now, in all these other ones, we said we're going to make this field unique, but here, you could have a track called Moonlight that could be on lots of different albums. And so actually, you can't make the title be unique. You can't say there's only one track in all of musicdom named Moonlight, because there's too many of them. So we have this UNIQUE clause, and what we're saying is the combination of title and album_id must be unique. And that is okay, on any album, there can only be one Moonlight track. But on a different album, there can also be one. And so those UNIQUE clauses can be kind of constructed to make the most sense, because if you say UNIQUE on here, if you put it on that one, then it's going to be unique. There will be no two Moonlights, and you'll be like, that's not a very useful feature. So this here is a kind of special unique. The combination of title and album is what's unique in this particular situation. Okay.
Play video starting at :5:58 and follow transcript5:58
So once we've built all these things, we can describe it, and you can kind of see after you create that track. You see that it's got a integer foreign key. That serial, when you saw that serial thing, it's really not null default nextval, blah, blah, blah, blah. You could probably type all that stuff in, but you could just say it's serial unique key, we're done. So we have a UNIQUE CONSTRAINT, it tells us what kind of an index it's using, it's using a B-tree index. And here we go, the typographical error is not in this, because the code actually works. So this is the foreign key references with our mark of ON DELETE CASCADE. So once you've created that table, you can ask Postgres what did I just make? And that's it's telling you what it just made.
Play video starting at :6:45 and follow transcript6:45
So up next, we're going to do some inserting of the data, and you'll see how these foreign keys work together and how we connect those things to each other.

# Inserting Data
So now that we built all of our tables, it is time to actually insert some data. So here is the first thing that you're going to notice. And this very first line is really important because you'll notice that we've always done INSERT INTO table name. And then we have the values, we have the columns and the values that we're going to use. But we don't have the id field, right? So remember the id is a serial field. So we do an INSERT, we do another INSERT, and the id values are automatically generated for us. So Led Zeppelin gets number 1, AC/DC gets number 2. I mean I only said don't replicate string data. We're going to use numbers. We have now assigned, for as long as we're going to run this database, Led Zeppelin is number 1 and AC/DC is number 2. That's not really a value judgment about rock and roll, that is a primary key that's generally internal to the database. And so then we have to make these connections, right? So we want to connect the albums to the artists. Now, we have to know this and I'll show you a couple of different ways to remember these little numbers. But we basically can't tell it easily how to set these artist IDs. They're not automatically set in the same way that the IDs are automatically set. And so in this one, you notice there's no id that we're inserting and so we have a title and a artist_id and we had to remember, you just kind of write on a little piece of paper or something when you're doing it by hand and that's exactly how I do it. When I inserted on that previous screen, I remembered that Led Zeppelin was 1 and AC/DC was 2 and then I construct these by hand. And later we will see quicker ways to do this once we know a little bit more SQL. And we're going from the outside of these trees, right? So we got track, we got album, we got artist, and we got genre, right? And we're kind of working our way in from the outside to the inside and then eventually we're going to get to track. So really we're just establishing what the primary key for Rock and Metal are so that we don't have to use those over and over. So it's not too bad. Now this starts to look complex but this is part of where, if you've been having conventions all along, you just I type this really fast because it's just following a pattern, right? So we've got id, that's going to be taken care of automatically. We got the title and then we got our length, rating, and count that come in and these are in the same order. The values are in the same order as the columns. And then we have two primary keys because here on track we point to album and we point to genre. And so that's what these things are doing. So we just know which album it is and what genre it is, which album it is, what genre it is, and we just know those numbers. And when you're doing this particular following along, hopefully you're just cutting and pasting these things. But if you have to do it from scratch, you just keep track. You got a little table that is the album IDs, the artist IDs, and the genre IDs, a little piece of paper, and then you can do all this stuff, okay? So that's like a whole bunch of fuss just to not replicate these strings, right? We effectively create rows that represent those strings once and then we get primary keys for those things and then we use these primary keys in foreign key columns to make the connections. And away we go. So we've built the relationships that we need in our data. Abd it's really just numbers, it's not that much more complex. So once we've spread this data across all these tables, then we're going to actually have to reconstruct it because our graphic designer who designed this UI didn't really want numbers to be shown to the users and so we still have to reconstruct this and we want to do that efficiently and all these numbers are also a form of compression, strings are bigger than numbers and if you have millions of them, it matters. And so we're going to take this compressed data that's all now links, re-link it together, and produce the output that we want.

# Using JOIN Across Tables
So now that we've spread our data out across all these tables, created primary keys, and linked them together with foreign keys, it is time to actually make some sense of it. And this is the power of relational databases. Again, I've only showed you like a little of seven records. You have to imagine millions, instead of seven. So now we're going to take these foreign keys and we're going to traverse the foreign keys to walk across this web of information that's now efficiently stored. The SQL construct that we use for this is called JOIN. The JOIN operation links across several tables as part of a SELECT. So it's an extended SELECT that extends across a number of tables. And you have to tell JOIN how to connect the tables and that's what's called the ON clause. So we have all this data and these are just the tables that we just got done creating. And so we have the id, and we have the foreign key, and so we're going to connect them together. So we're going to get a SELECT. We want to produce an output that looks like this. We don't want the numbers any more because that's not good for users. Those foreign keys or primary keys are just bookkeeping stuff we do as database creators, but we want to make it so it looks nice. So now we're going to have the SELECT. We have a slightly different format now. We have the table name followed by the field within table album.title, artist.name. So we're now selecting data from two tables, and so we say, oh well, FROM FROM. You can do this in either order. So we're going to have two tables, the FROM the album table joined with the artist table. So we're horizontally connecting the album and the artist table. And I follow the arrows. So I start in the album table and then I'm kind of like looking these guys up, I'm saying,oh, okay, 2 and 1, I want to turn those into the strings. So you could do it either way, but I tend to go FROM and I tend to follow it. So album joined with artist. Then we've connected these two tables, but then we have to have this ON clause to say when rows are connected and we want the 1 to connect to 1 and 2 to connect to 2. That's important because that's meaning we in effect look up the corresponding string of name, given the foreign key 1 or 2. Right? And so that's what the ON album.artist_id equals. That's the album artist_id field, and equals artist.id. Now again, when you have a convention, I can look at this and I can note, okay, that's a table named album, artist_id is a foreign key into the artist table, artist.id is the primary key. And so I can see all that stuff. And so it goes through and it looks at all these things and it connects those and shows us only the data. So one of the things that the SELECT, I didn't make too much of a fuss about it, SELECT picks among the things that you could see. It shows you what you want to see. We don't want to see the id, we don't want to see artist_id, or id from artist, but we could see all that, okay? So SELECT picks what we want to see. So that's basically how we can say, I'd like to see a little bit more. I want to see the album title, the album's artist_id, the artist's id. So we're going to explore and show the data that is the part of the ON clause. Now, in the previous one we just didn't show it. So if we just add these and the rest of those, it's just adding those things compared to the last one. And basically, you just get these two columns where artist_id and id and then it just shows you how the ON clause has made that connection for you. Now, that's what's called a INNER JOIN. So the INNER JOIN is filters where they match, right? But in a sense, the JOIN is taking and looking at all possible combinations of these things. Now, in a table where there's only two and two, the number of possible combinations is four. All the rows of the first table combined with all the rows of the second table, that is four. Now, you can actually express a JOIN, and it's called a CROSS JOIN. So the INNER JOIN means take the things that match. CROSS JOIN means join everything. And you'll notice that this CROSS JOIN doesn't have an ON clause because it doesn't need an ON clause. So track CROSS JOIN with genre, says take all the combinations. And in this case, the track has four items in it, and the genre has two items in it. So we end up with eight rows when we come back. And we're also seeing the genre's id and the genre.id which is the thing we're eventually going to use as the ON clause, but you'll notice in the CROSS JOIN, in particular the CROSS JOIN, we both get the ones that match, and we get the ones that don't match. The difference between the INNER JOIN is these ones that don't match, 2, 1, and these get chopped out when we're doing the INNER JOIN, but the CROSS JOIN shows us all those. So the CROSS JOIN is like the INNER JOIN with a WHERE clause. You can almost think of the ON clause as a WHERE clause after you've done a CROSS JOIN. Normally, we don't want to do this, but sometimes we do want all combinations. This is not a very efficient thing. Imagine a million on one side and a million on the other side. You don't really want that. You just want the ON clause and the connection. I'm just showing you this, not because I expected to do CROSS JOINs, but just so you kind of get the basic mechanics of what JOIN is doing. It's like taking combinations and then filtering. The whole JOIN is these eight rows, right? And the ON clause throws away the rows where these two fields don't match. And in some databases, you do this not with a JOIN and an ON clause, but you just say, from this, comma, that, comma, that, and put it on the WHERE clause. I don't think that's as pretty, but you might. And that's okay. When we're going to do this with the INNER JOIN, which makes a lot more sense, right? Now we're going to do an INNER JOIN. If you don't say INNER, it's an INNER JOIN, which means it's filtering. You take all the tracks, and you look up and you put the corresponding genre in. And we're only asking for track title and genre name. So this is a normal JOIN, INNER JOIN, with an ON clause. And all I'm showing here is, this JOIN will reconstruct that vertical replication, right? The JOIN will reconstruct the vertical replication. The Rock, Rock, Metal, Metal. So that was the thing we didn't like, but that's the thing we need for the user interface. And this gets complex, but again when I write this, I write it really fast because all my JOINs look the same. All my field names look the same, all my patterns look the same. So I'm going to say, I want to see the track title, the artist name, the album title, and genre name from the track joined with the genre, and here's the matching condition for that JOIN. Joined with the album, here's the matching condition for that JOIN. Joined with the artist, and here's the matching condition for that JOIN. Again, you can kind of see how I'm just going to copy and paste, change a little bit. And it's not that all bad. And we're only seeing the text things. And now, what you see is you see the title of the track, you see the name of the album, you see the name of the artist, you see the title of the album, and then you see the genre. And you see all that vertical replication back. Again, I like to think of this as with all of this, we compressed the database using numbers rather than strings and JOIN reconstitutes the strings, but it's not stored anywhere. It's just sort of at the last moment, we make the strings and we show them to the user. And then it's really efficient still sitting in the database. And so that was a long set of data models, and serial columns, and IDs, and foreign keys, and primary keys, and all that stuff just to go from the point where we had a prototype UI that had vertical replication in it, to a database that had no string replication in it, back to a UI that we can then reconstruct on the fly using all of this JOIN stuff. Now the one thing I want to touch on is this ON DELETE CASCADE which I put in all those CREATE statements. Now that we've done this, we can see how this ON DELETE CASCADE. So you can think of a many-to-one relationship, meaning many tracks go to one genre, or you can think of the genre as kind of a parent row. And the question would be, what if we removed that row? What would we do with these? Because these point now to a row that doesn't exist. And so this is where the ON DELETE CASCADE is helping us maintain these internal links. I told you that these are just kind of integers, but when we have a constraint foreign key, we tell it that oh, I know what, when this parent row gets deleted, what to do with the corresponding rows in this child field. Okay? So when we say ON DELETE CASCADE, that means cascade delete from the parent into the child. So once you delete this row, these rows are going to be gone too, okay? So if you run this command, that is going to not just delete one row from the genre, but it's also going to delete two rows from the track, right? We have four rows. We delete one row from genre and then we've inadvertently as a side effect, we have deleted two rows. The ones that had a genre id of 2, we've deleted those rows from the track as well. So that's how the ON DELETE CASCADE. Now, there's more choices that you have. You can do RESTRICT, meaning that that delete of Metal wouldn't work. Meaning that if you delete Metal from genre, then there's going to be these rows in track that don't point. And then that would be a failure. It would blow up on us. Remember that when SQL blows up, it's often because you or I asked it to enforce a rule. So if I said ON DELETE RESTRICT, that means don't let me delete things if I would break my internal data model. And you like that. It may seem wrong to you, like how come I can't do what I want to do. Well, then tell it you want to do that. CASCADE is the one I tend to do because it keeps your data model clean. So if you delete a parent row, you throw away the child row so the consistency is maintained. And then the last thing you do is you can set it to null, which effectively deletes not the whole row, but it deletes those foreign key columns. So you don't end up with the 2, you end up with null in that. Meaning it doesn't point. Now, if you're going to do DELETE SET NULL, you've got to allow your foreign key to have a value of null, because you can decide whether or not is this an integer field or integer null. Meaning integer null field means I'm allowing nulls in this field, which null is empty. So I'd have to say INTEGER NULL, if I was going to say ON DELETE SET NULL. And it wouldn't even create the table that way. Again, you always think, like, oh, it won't create the table, that's so mean. It's like no, just put DELETE CASCADE. I don't know. It's a weird thing that you've got to get used to when you're building databases where you're like, I have decided to make you enforce rules on me the programmer, because it saves you all the time. So that's your choices for ON DELETE. So the next thing we're going to take a look at is many-to-many relationships. And at this point, you're probably thinking, well, artists and albums, that's not quite right. Yeah, because they're not really one-to-many relationships in the real world. So now we're going to get to an example that shows you the other really valuable way of representing data called the many-to-many relationship.

 