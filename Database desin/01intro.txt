# Welcome to PostgreSQL!

Hello, and welcome to Postgres for Everybody. This is a course that I have dreamed of teaching for over a decade. You may have met me in another course, like Python for Everybody, Django for Everybody, or Web Applications for Everybody. You'll see in each of those courses, in all those courses, I have to teach SQL. It turns out I teach basic SQL over and over again. It's like being a kindergarten teacher because I cannot go into the detail that I want because in each of those classes I have another topic to cover. So I have to teach you CRUD, Create, Read, Update, Delete, what's an index, what's a join, what's a foreign key. And then move on into whatever topic that is. And a lot of you have told me over the years that you like the SQL part of the classes and that you wish that you could program more in SQL. And really, as I build online teaching and learning applications, the SQL part is almost the most creative part. Others are better at designing pretty user interfaces. But for me, the SQL is where the essence of applications and performance comes from. And so there's just way so much more to learn and it's so much fun to work with. And so this is my moment where I now have a series of courses that can do nothing but databases, teach you as much as I want. I don't have to do anything but databases, and so that's really exciting to me. Now, you might ask why Postgres? Why PostgreSQL? Here's the little elephant, that's the mascot of Postgres. Good open source projects need mascots. Here's the mascot from my Sakai project, the Sakaiger. I've got the Postgres mascot and the Sakaiger and a Postgres mascot. So there you go. So why Postgres? I do like open source, but then you might say, why not MySQL? And I'll just say this. I felt that way too. I used MySQL for a very, very long time. I love open source. I build a lot of open-source software. The autograder that you're going to take this class, that actually is using MySQL. But here's the thing. It used to be in the beginning, it was easy to know what database was the right one to use. You might use Oracle if you were in a corporate environment and your company had chosen Oracle. You might use MySQL if you were an open source environment and you insisted on giving folks free stuff. You might have used SQL Server, for example, if you are at an organization that is a Microsoft shop. And so it just seemed like based on sort of where you started, the answer was obvious. And then a while back, Oracle purchased MySQL. Now they didn't purchase all of MySQL. MySQL is open source, but they purchased enough of the team building it so that Oracle owned the future destiny of MySQL. And so some of us got a little nervous because a lot of us had chosen MySQL just to avoid Oracle. I don't want to go, I don't want to use Oracle, I don't want to pay every time I like install something. Now, what happened at that point was someone grabbed the open source copy, they made a copy of the open source MySQL and called it MariahDB. And the idea was, as MySQL would continue, then the open source people would keep releasing MariahDB. The problem was that also happened about the time, as we'll see later in Postgres for Everybody, the competitive environment for databases was increasingly challenging. Challenges from NoSQL storage. The need to store JSON, something that classic relational databases hadn't really thought of much, but it turns out are very, very important. And relational databases sort of saw their grasp on the world slipping away as things like Mongo and Cassandra came out that were NoSQL databases. And so relational databases like SQL and Oracle and Postgres had to react. And the problem was that MySQL 5 was pre all of this reaction and all this market concern. And so Oracle had to invest in MySQL to make it competitive with all these other products, and they ended up releasing a thing called MySQL 8. And the Mariah database community will have to see the extent to which they have kept up with MySQL 8, I believe it's Mariah 10. If enough of us open source people jump on Mariah, that'll work. But the problem now is the MariahDB is a change, a small change, for MySQL folks. Maybe Mariah will be the answer. But Oracle, I mean Postgres, has become kind of like this interesting alternative because it's ruggedly, solidly open source. And you may or may not have heard that Amazon, when it first started in the late nineties, chose Oracle. Why? Because it's what you did if you wanted a fast database and you didn't want to become a database company, which is not what Amazon wanted to become. And so they built a lot of stuff around the Oracle database. Well, the problem is that that cost them a lot of money and as Amazon got bigger and bigger and bigger their Oracle bill got bigger and bigger and bigger. And that made Larry Ellison, the founder of Oracle, very, very rich. Rich so much to the point where the Iron Man character is based on Larry Ellison. And so Amazon spent a great deal of money to stop using Oracle, but instead use Postgres. And they've done that. I believe they announced sometime back that there is no more Oracle used inside Amazon and it's all Postgres. And so this whole thing is making a lot of us, open source and otherwise, look at Postgres, and you should be looking at Postgres as well. I have taken a look at Postgres and I'm happy with what I see. The Oracle, the Postgres community is a very, very good open source community. I'm a big fan. I'm jealous in many ways. They're big, they're talented. They have been doing this for 20 years and it is an advanced SQL database. It's solid, it scales. Amazon bases its stuff on Postgres, and so it is time, I think, for us to take a really serious look at Postgres. So I'm happy that my first foray into advanced SQL is to introduce you to Postgres. So I hope that you will be as big a fan of Postgres as I am once this course is complete.

# History of Relational Databases
Hi and welcome to relational databases. In this class, we're going to teach you about Postgres. Postgres is a really cool database. It's both open source, but it has a lot of features. So you might wonder why it is that we are so obsessed with teaching about databases. And for those of us who've been around a long time and started like in the 70s when I started, it's quite amazing how fast databases are. We just use these things so much and we take them completely for granted. When you log into a system like your learning management system, that system probably has 50 terabytes of data and you type your name and your password, and a quarter of a second later it knows what classes you're in, and what your notifications are and all these things. And you probably don't even wonder how it is that it can go through terabytes of data in a quarter of a second. And it wasn't always that way. And so I'd like to start with a bit of a history lesson talking about what things were like before databases. And honestly, you kind of have done this kind of work if you learned Python and you've done simple data mining and we said read this file and do something. So the problem that we have is it's not so bad to read a file, although in the old days we had to use magnetic tapes. Let's see if I got this right. Magnetic tapes. So this right here is a magnetic tape and in the old days we didn't have spinning disks that could hold all the data for an organization. The memory of the computers was small, the disk drives were small, and so we stored data on tape, and the problem that tape has is it's a linear thing and if you're looking at the tape here, it takes seconds or minutes to move to look at the data here. So the biggest delay that we had if we had to store a lot of data was the access time to go from one piece of data to another piece of data. And so we had to still solve the problem like if you're at a bank of people sort of depositing and withdrawing money from the bank and then your database is on this sequential media. This tape that takes perhaps an hour to go from one end to the other. And so we came up with this idea that we would put all of your old data on a tape sorted by account number and then we'd have a printout in each bank that had your balance as of midnight last night and you would come in and you would do a deposit. They would fill a loads deposit slip and you put your account number on it and you might take out a withdrawal. They might check the little piece of paper to see if you had the right balance, had enough balance to withdraw. But then you'd end up with these transactions and these transactions are the daily activity. And then what we would do there's this thing called a card sorter. We would literally punch them on cards and then we would physically sort them so that they were in an ascending order. So that the lowest account number was at the beginning of the cards and at the beginning of the tape. And then at night after the bank closed, we would have all these things sorted and we would mount one of the tapes on one tape drive, and then we would kind of pull it through the computer. I think this is a card reader here. Pull it through the computer and then write a new tape. So that's what we would do. And so this new one. But we took advantage of the fact that the data was sorted and we kept the data sorted forever all the time. So the way it would work is a program would read one record from the tape and it would read one record from the cards from the transactions and it would compare them. And if this card record was greater than the first tape record, which it most likely was, it simply copied the record and then it went to the next record and then it would read the next record, and at some point it would copy enough records to the point where it got to that first record and these two match. At that point you update and put the new record in and then you advance to the next transaction in your input data. And you'd see that then you are advancing through this when they match, but you'd never go farther. You'd never go ahead. You always look at the current transaction. So if you think about the amount of data that actually had to be stored inside the computer's memory at any given minute, this could be hundreds of thousands of records. This could be thousands of transactions. But literally the amount of data you had store in the memory of your computer was one transaction. One transaction from the tape and one transaction from the input. And we called this thing a sequential master update and the way it ultimately worked was you would do this sort of blending of these things. They would be sorted and they would end up with a new sorted one, and then you would take this and the next night you'd make that be the old sorted one and then the next day's transactions. So we had these tapes lined up in tape racks. This was last night, and the night before, and the night before, and the night before, and the night before, and then there's the tomorrow. Day after tomorrow and a backup of two weeks ago and that's how we handled data that needed to be modified and searched. Okay? And so that's the way it was. But of course that's not true today. Today, we have disk drives. Or even faster, we have SSDs, solid state disks, that are even faster. And so the key thing that happened in disk drives or solid state disks was that your data is still sort of permanently magnetically stored somewhere and there's a series of rings here on this disk drive and you had this little servo that would move the head in and out. And so if you look at disk drives, and disk drives are becoming more and more rare, there was the speed at which the head could move and the rotational delay and so the revolutions per minute of a disk drive and the access time. Those are the two things that we categorized disks. And so as these became more common and the size of disk drives got bigger way faster than the memory, and so you literally could store all of the account data on a disk drive. Now, disks were faster than tapes and you can imagine that the first thing we would do is we would do like a sequential master update. So you'd have like your old data somewhere. Then you'd have your new data and you'd read through it slowly but surely and read all the transactions, except that you're not really taking advantage of the fact that this literally can move from, and if look at all of your data, all your data sitting here, you could move from here to here in 100th of a second or several thousandths of a second. So you didn't have to have any delay and the distance here didn't so much matter. It mattered a little bit if it was kind of coming around, but that's a subtle optimization, meaning that you could literally if you could think of this as your one terabyte of data, this whole thing, you could hop anywhere, no matter if it was close or it was far. But the cost to go from one piece of data to the next was the same. So then the question comes, how would you build software so that now we can make it so that your account balance is updated the instant you take the money out or make the deposit? And sequential master update is not best idea, although sorting still turns out to be important. And so in the '60s as these technologies and then the '70s as these technologies became common, a lot of companies started building the notion of databases. And we've ended up with the results of decades of research in these amazing pieces of software that we call relational databases. The relational databases are instead of reading the data sequentially, you know how to properly bounce around in those data. So we come up with this data that ends up being stored as a network of data on this disk drives that you can bounce through really fast. So it is an amazing thing. It's grounded in mathematics and there is mathematics that make these relational databases that are the reason they work so well. But it took a long time before we had software that's sophisticated enough to meet all the needs. Now, as these databases evolved in the '60s and the '70s, there became like vendors. And these vendors were sort of powerful, like IBM and Burroughs and others, and some companies that don't even exist anymore. And they came up with strategies for building a database. And each company sort of had brilliant people who were building really cool databases and then they would get something cool working and then they would try to convince everybody to use IBM hardware or Burroughs hardware. And if you bought IBM hardware, you had to use the IBM database. And if you bought Burroughs hardware, you had to use the Burroughs database, and it turned out that they didn't really have a common model. So IBM might try one strategy and this is not necessarily because they're bad. It was because everyone was researching it. So at some point there was the need to standardize on databases and the standard that now we use and take for granted that came out of the National Institute of Standards and Technology, NIST, is called SQL, Structured Query Language or some in the old days I think they call it Simple Query Language. And the interesting thing, and you can see this video from Elizabeth somewhere else in this course, it was perfectly timed, meaning that the vendors had built things that they knew were good, they knew good ideas, and they had good ideas and there were different ideas from different vendors that were all pretty good. But yet they had not gotten so mature that they were just going to fight each other. And so the National Institute of Standards and Technology basically said to all the vendors, "Look, we're not going to tell you, you know more about databases than we do, we're not going to tell you how to build a database. What we're going to tell you is we're going to stop buying your software unless you come up with a standard and we'll help you with meetings and we'll run the meetings and take notes. And eventually there will be this standard." And this SQL, the Structured Query Language, came out of that standard. We were present at the beginning of it. SQL is a beautiful thing. It is a beautiful programming language. It is my favorite programming language and when I'm not allowed to use it because I'm using an Object Relational Mapper or some magic thing that makes SQL easier, I'm like Stop it. SQL is beautiful. And the reason that SQL is so beautiful is that it's non-procedural. It's the most powerful language that I've ever used that's non-procedural. And what's the difference between procedural and non-procedural language? A procedural language you say start here, do this next, do this next, do this next, oh wait, go back up, do this next, do this next, go back up. Okay we're done here. Now oh skip this part, do that. All that sequence, all that like I call it like GPS navigation, turn left, turn right, go straight. That's procedural. And actually that's how computers really work and so at some level you still have to write procedural. But what SQL does is says, You know what? I've got these tables of this stuff over here, please assemble it to me. I don't really care how, what you do first or second. It doesn't matter. All I want is I expect this is what I express the fact that this is what I want, and then the database system completely optimizes that and it is an abstraction. Our expression of what we want is very different than the action that is taken by the database system to assemble that. And it can actually watch what I'm asking for and it can optimize later and move things around. And some databases systems do that. They actually figure out the pattern of usage and then reorganize the data, so that the kind of things that I'm asking for are handled more efficiently. And so the key thing about SQL is it's not the way that they build databases, but it is the way that we talk to databases. And it's high enough and abstract enough that every one of the database vendors is able to build a really cool implementation and they can sort of compete with each other and build a better implementation. So if Postgres is better than Oracle or Oracle is better than Postgres, they can fight, they can compete. But then we simply use SQL to talk to it. Now, the SQL turned out to be quite early. And so there's a few extensions and we'll see those things but a lot of the core SQL is either the same or very, very similar. So the critical core bit, and we'll talk about this a lot, is called CRUD. The critical notion is that there are four basic things that a system to store data is you're going to create some data and put it in, you're going to pull some data back out, you're going to change data, and then you may delete data. So that's the thing that we're going to focus on making fast and simple to express. So as I mentioned, databases have a mathematical basis. The relation is like a math term, so relational databases is like, I hear that as like databases that have the theory of math built into them. And if you read database documentation, you can tell whether they were written by someone who's kind of a software developer or someone who's more of a software "theory" person. So the theory people will say things like relations and tuples and attributes, and people like me who are programmers will call them tables, rows, and columns. In there is the truth and don't feel bad if you see weird words that describe something to you that seems very, very familiar. So ultimately, I said earlier that the data is modeled as a network but it's also modeled as a connection. And so it's not just like a road system. It is more sort of an abstract connection point. The combination of a row and a column has got data at it. And we have attributes and rows and columns and tuples and relations. We're not going to worry too much about that because we just use this software and it's magical. I talk about this a little bit just to appreciate those that came before us that built this wonderful software that we're going to take advantage of. As a programmer, I think of this as just like a spreadsheet. The tables are like the little tabs across the bottom. The columns are the attributes and the rows are the tuples and in a spreadsheet we commonly have that first row have some metadata about the rows, and sometimes even if you're sorting a spreadsheet, it's like do you want to not sort the first row because it sure looks like the names of things and that's actually something that we do inside of databases as well. We call that the schema and it's much more formalized than hey let's use the first row to represent the metadata about what's in the row. But really you can think about these things as a large spreadsheet as a software developer and that's the beauty of the abstraction, is that you just sort of say, you know what, Oracle is a multi-billion-dollar company and they spent decades building something really fast. I'm going to pretend it's a big fast spreadsheet and that's how it makes our lives easier as a software developer. So I've already mentioned Oracle. There's a lot of different database systems out there and I've taught most of these and on this screen I've used every single one of these at one point or another in my career. And that's one of the cool things about SQL, is that you learn like 80 percent of it, 60 percent of it, and literally in all these things it's the same. I've taught SQLite to use in Python. I've taught MySQL to use in my Web Applications for Everybody class, and I'm teaching Postgres, and I've used Oracle professionally and I've used SqlServer, professionally. And HSQL we use in open source projects. So everything on it, I have used every one of these. So, SqlServer. I'll start from bottom. SqlServer from Microsoft. It's one of Microsoft's very strong products and so don't feel bad if you end up on Microsoft. I usually feel bad when I'm using Microsoft stuff. But the Microsoft SqlServer is a solid piece of software. MySQL used to be my favorite but Oracle bought it. And so it's technically open source but there is a certain fear in the marketplace that Oracle is potentially going to like bend it towards commercial and say "Well, here's the crappy open source version and if you want the speedy version, that you have to pay for." They haven't done that yet. Oracle is the gold standard. It is large, it's commercial, it's enterprise scale, it's very tweakable. Among all these it's by far the most annoying and complex to maintain. I dislike Oracle. I mean, I've run all these and every time I touch Oracle it's like, "I got to write myself long documentation about how to do the simplest of things in Oracle." I'm sure if you're an Oracle expert, you're like "Oh, but it's so easy." I'm like "Yeah." The other to me Oracle is harder than all the other ones combined together as far as I'm concerned. But in commercial situations, it's what's going on. Now Postgres is the one I am teaching most recently. As a matter of fact, right now. I never have used Postgres professionally. I've never used it in an open source project. But because of the questions that have been raised about MySQL, I think the market is gently drifting toward PostgreSQL. So companies that I know are going to Postgres because it's free and open source and it doesn't have the Cloud the way MySQL does. And it has a lot of features, kind of like Oracle. And so historically, Postgres has more features. Oracle and Postgres always had more features. MySQL is catching up
Play video starting at :18:54 and follow transcript18:54
but in the catching up you might have features that only come in a commercial version of it. So it's like let's just use PostgreSQL going forward. And so that's why I'm teaching you because what I want to teach you in this class is some of the more advanced features that are part of PostgreSQL and I want to teach you an open source product. So we're learning PostgreSQL. It's all open source. There's unlikely that it'll be anything but open source going forward and it's a very feature-rich database. So coming up next we're going to talk about SQL Architecture and how it is that we can start writing SQL statements.

# Elizabeth Fong and SQL Standards
One of the wonderful things about SQL is that much of the core of SQL is a standard, and that standard was developed early enough to have a major impact on the development of relational databases (Oracle was a small startup back then).

The creation of that standard was facilitated by the US Government through the National Institute of Standards and Technology (NIST).  Elizabeth Fong was part of that early groundbreaking work and shares her perspective on how it all happened.

The video was filmed and associated with an IEEE Computer Magazine column I wrote.  Here is a quote from that 2014 article:			

The rotating mass storage that enabled random access to large amounts of data is one of the key technologies that helped computing evolve from long-running batch processes to something more in the moment and interactive. However, these mass storage devices were limited by seek time and rotational latency, so computer scientists and vendors spent decades optimizing how applications could best utilize them....

# Bonus Video: Elizabeth Fong and SQL Standards
And they were part of the coming, going from wild. And then we realized that, hey, I want to buy a product. What kind of a feature do I need? Another one of the things that I have done is the feature analysis. So we have about half a dozen of product. And the standardization are really building a consensus. We brought from a matured technology that are ready to be standardized where people say, do I buy IBM or do I buy Oracle, or shall I buy a cheaper one? This kind of a decision started emerging. And selection of, I mean, how many variety of application you can build on top of a software foundation, what I call a database management system, is too varied. And so you want to have some sort of a standard so that your application can work on different platform.
Play video starting at :1:54 and follow transcript1:54
We work with files, and we call it the file system. The files are hierarchical, they were in the IMS,
Play video starting at :2:2 and follow transcript2:02
the IBM information management system, which is a tree structure. And the debate was going on whether there should be a tree or a network or a flat file. And we are still debating whether the data have a self-describing tag, and later on, we known it as a metadata. And now, people call it the schema. So the Database System Study Group come up with a reference model or a specification for a minimal functionality of a database management system. In order to be a database management system, you want to be able to store data, retrieve data, modify data, organize data, delete, manipulate data, and it becomes a spec.
Play video starting at :2:59 and follow transcript2:59
And during that time there was a birth of a, we initiated a birth of a ANSI group. It's now called INCITS, the ANSI American national standards group. And it's called the X3H2 of which Don Deutsch and people like Len Gallagher all participated in that. That group is called the data management language.
Play video starting at :3:32 and follow transcript3:32
In order to standardize anything, you
Play video starting at :3:36 and follow transcript3:36
realize that you can have a lot of light bulbs, for example. You can have red light bulb, white light bulb. The only thing you want to standardize is when you want to talk to another person. Communication, interface, or a area where both of us have to understand a common vocabulary, or whatever. So the standard, the only standardization of a software system is not the capability but a language.
Play video starting at :4:18 and follow transcript4:18
And relational database at that time was IBM, Chris Date, and he's talking about normalization. He started talking about flat file and he called it a table, and it's a very easy concept that everybody understand. So in order to retrieve a table, you say select from a column such and such, from a table of employee, and there was a birth of a simple query language.
Play video starting at :4:56 and follow transcript4:56
Testing part is also very important aspect of when you adopt a standard. You want to certify that the product conform to such and such version of ISO standard, or JTC 1, whatever it is. So that gets to be if your, otherwise your app won't work. Your application, let's say you build a student course record. And no matter, you got Oracle, you got a Xybase or Microsoft SQL, you want your application to work no matter what.
Play video starting at :5:40 and follow transcript5:40
And that's what the marketplace wanted to go, the user. Of course Oracle, or Microsoft, buy my product, Oracle would say buy my product. And in the procurement, you say, I want to be compliant with SQL. And so you have to have the conformance testing certificate. And we have the NVLAP, it's a laboratory that's certified and gives you a validated product list. Here is the list of product that have been validated that they conformed to it. And you can buy from that list, but there is a requirement. This is strictly user. You're buying, because you're paying the money, not us.
Play video starting at :6:33 and follow transcript6:33
Timing is everything.
Play video starting at :6:36 and follow transcript6:36
You can't standardize a thing too early, or you drive a lot of innovative concept away. Because people say, hey, there's no way for me to get into your market, because you already decided. And even though it's not very good, I won't get into that business. So, you killed innovation. And if it is too late, you missed the opportunity, you get too many variety of things coming up, and the choice is too much. But, of course, SQL is one of the success stories that we have.

# SQL Architecture
So now we're going to talk about how we actually run SQL commands to talk to the SQL server. So even though you may be running everything on your laptop, or you may be running it in a server with the SQL server running on the same hardware as you're running your SQL commands, the best way to think about SQL is that there is often a database server. And so in production systems and in scalable systems, in effect, you have a client, so this is a client, and then you have a server. The client and server might be on the same computer, but the key thing is to mentally understand that this client is very different software than the server is. The server is the magical software that comes from a decade or more of amazing software developers who figured out the math that joins all this stuff, the magic performance. Just let's thank these people who wrote these servers and how smart they are so that we don't have to be that smart. Now, if you want to be computer scientist, you can spend your whole career making one tiny corner of this a little faster, and that's what PhDs are written, PhDs in computer science. In fact, my Master's degree can be thought it's a dot, it's so small that you could barely detect it. So a lot of smart people have made this database server. What we do is we basically type in SQL commands and we send them to this server and then the magic happens and there's disk drives and stuff like that, data comes in and out, there's memory, it's all cached, all kinds of fun stuff, and then we get our answer back. Right? So the way we perceive this, is we talk to some kind of a client which forwards the commands to the server, which does all the work and then gives us this thing back. And so you can have software that runs in a web browser like Postgres Admin, or that can run as a desktop application, but I'm going to focus on using the command line, and I'm going to teach you most of this class to use command line. Everything that I'm going to teach you, you could use in the other clients, but I like command line in particular because it's easier for me to document and I'm not spending so much time making screenshots, but it's also more accessible, meaning that people who have visual impairments can use the command line I think a lot more naturally than some full-screen software. So we're going to do Postgres on the command line. The other thing that I'm going to do in this class, is I'm going to teach you Linux. Now, most of what I'm going to teach you in Linux would work in Mac OS under the Terminal, it could work in Windows with the Bash shell if you're doing that, but I'm just going to show you the Linux and if there's a little bit of adaptation that you have to do or if the output is a little different on Mac or Windows Bash, or you can figure out how to use Windows native, I just think ultimately the world is accepting the fact that on the servers we're going to run Linux. Linux on the desktop, that's a different kind of religion, but Linux on the servers is just done. So there's a lot of stuff we're going to do on servers and so I'm not going to hide it and I'm going to teach you Linux. So we have a dollar sign prompt, it's Linux, and I only have to show you one command. Sorry, I've taught a lot of classes that I just have to say in Windows and in Mac and in Linux. Actually, what I do is I teach Windows and Mac and never teach Linux, which probably was the wrong thing. Now I'm going to teach Linux and not Windows and Mac. Chuck, back to the lecture.
Play video starting at :3:38 and follow transcript3:38
Remember, there is somewhere magically out there on the other side of the Internet, a database server. This client, psql is a client that we're going to run locally. Now somebody, either you or us, have set up a Postgres server out there, and there is when you connect to that server an account and a password. And based on that account and password, you get permissions in the server. So when you first set the server up, you create what's called the superuser. And there is the postgres, and postgres is the superuser, and that's all we're saying here. Let's log in as postgres, and then you have made a superuser password, usually that's part of the install process. You may or may not have this, it's okay if you don't, and then we get the prompt. And so it's a command line prompt, and the pound sign is kind of the Unix old school way of saying you are the superuser, and you can do things. In particular, we can create other users. So this is a joke from xkcd. I love xkcd in particular because he makes his comics Creative Commons attribution which means I can put them in this lecture. So this person on the left says, "Make me a sandwich" and the person on the right says, "What? Make it yourself." And the person on the right said, "S-U-DO. SUDO, make me a sandwich" and the other person says, "Okay." So what's going on there? So S-U-D-O is a Linux command to upgrade your session from a regular user to a superuser, so you might say, delete these files with the rm command and it won't do it, but then you say, S-U-DO, sudo rm, and it works. So this is basically pulling the whole concept of superuser into a human context, and I've many friends who have this as a t-shirt. So, you're starting out as a superuser. Like I said, you may not be a superuser and so some of these commands that I'm going to show you that superusers do, you may have to have someone else do them or we may have done them for you already, and you know this every time I'm showing you a superuser prompt because it has the pound sign. But this \l command, is the command to list the databases, and this is a Postgres server instance that I just started, and you'll see that the owners of these three databases are all postgres, which is the superuser, and these are databases that you probably shouldn't touch because these database systems tend to store their own data in databases, and the reason for that is efficiency because they have figured out how to make stuff in database accessed very fast. So in a sense, when you make your own database or create a table in your database, it stores that information in its own database tables, right? And so you delete these and then Postgres is going to start blowing up in a bad way. So right now, I'm showing you how to see the databases and for now, there are no databases you're to mess with at this point. These databases will change based on commands that you're going to type to Postgres, but don't do anything to these. Don't think, oh I'll save myself some disk drive, so I'm going to delete the postgres database. Well, then Postgres will stop working. Maybe it'll warn you. I never even tried, so I don't know what happens because I'm not going to do it. Okay. So the first thing that you want to do is you want to create your own database because you're not supposed to mess with the ones that are already there. So this is your first SQL command, and so I'm putting them all in uppercase, they don't have to be uppercase. The first thing we see about SQL, is SQL is a little wordier than most programming languages. That's because single SQL statements are so powerful that we want to be able to have the best chance of sort of reading them. So we don't just like call it C-U-Z for create user, we call it CREATE USER. That's actually one command. So CREATE USER, and I'm going to make an account, and then I'm going to say WITH PASSWORD and I'm going to give it a password of secret, and then I'm going to say, CREATE DATABASE people, that database contains multiple tables, WITH OWNER pg4e. So now I have in my database server I've made a new empty database and I have access credentials that I can get in to that, so my SQL client can now talk to that database as long as I present these credentials. And then \q gets me out of that particular session because all I really wanted to do as the superuser was create the user and create the database. Now, in your situation, you might have been handed a database, user, and password, and that's enough to connect and start doing stuff. And so I'm just showing you this in case you're doing this all by yourself on your own computer how to get the whole thing started. So now we're going to connect to the database. And so we're going to say psql, start the client under at Linux, name of database, name of user, and then you enter your client, right? So now here, you got this database people sitting on a server, and then we have some credentials that allow us to get into that. So that's what we're doing. Okay? And now, for me the first thing I always do is like, what's here? In Linux, I type ls or pwd like, where am I at? And what do I got?
Play video starting at :9:13 and follow transcript9:13
You'll also notice we're not superusers anymore, right? And that's because you want to be careful when you're the superuser in a sense you want to type as few commands as you can in the superuser, we are now a reduced user, so we could have lots of different databases in here with different credentials, but this particular pg4e can't break any of these things. And so you sort of want to keep your credentials scoped as low as you can and not use the superuser except to make credentials and then use those credentials to do everything else, and that's what we're showing here. dt shows the tables, but this is a good example of where you see sort of two terminologies. There's dt says tables, and then we hear relations. So relation is the more hoity-toity of the terminologies and tables is the more like I'm a nerd version of those terminologies. So we have no tables and we're not a superuser. So let's make a table. So here we go, we're going to make a table. CREATE TABLE, the name of the table, and then a parenthesized list of schema. Remember I talked about the spreadsheet. The schema is our contract with Postgres that says this table's got two columns and it's got two character columns, and each of those columns is up to 128 characters long. This is the schema, we're making the schema here. And it's a contract, meaning if you try to put 129 characters into this, Postgres is going to blow up, and you're like, you're so mean, Postgres. No, Postgres is doing what you told it to. You told it that you're never going to store more than 128 characters. Why is it so picky about this? That is because Postgres takes every hint that you're giving it about the shape of your data, and it's storing it as efficiently and most compactly and fast retrieval, and it's got to solve a lot of problems so you have to tell it what and how you're going to use it. And if you wanted to store 129 characters, just store 129 characters, but don't tell it you're going to store 128 and have it build a whole structure efficient for storing 128 and then try to store 129 and complain about it. Now, we'll see there are ways to store this data to say, "Look, I don't even know how long it's going to be, just give me a space," and it does. And it does that as efficiently as possible. But if you know you're going to be 128 or less, then tell it. So that's what we're doing. So we have this kind of column name and then data type, comma, column name, data type, and then parenthesis. This parenthesis here matches the users parenthesis, and then you end these things with a semicolon. And so now I made a table, and I can see the table, and I can see oh yeah, okay, I got a table named users, it's a table and the owner is pg4e. Now, I'm not a superuser so I'm only seeing the ones that belong to me which is pretty cool, and I can say \d+ which says show me the schema because sometimes you made a table a long time ago and you forgot what the CREATE TABLE was, and so you could say, show me the schema of the users table, and so you then see the schema of the users table. So up next we're going to talk about how we take these tables that we just created and type SQL commands to put data in, take data out, the actual CRUD: Create, Read, Update, and Delete. Okay? So that's what we're going to do next.

# Using PythonAnywhere to Run SQL

Hello, and welcome to another recording for PostgreSQL for Everyone. Perhaps the first recording you're watching. So today I'm going to show you how you can do all of the homework using the psql command on a Linux shell that we get for free from PythonAnywhere. First, I want to introduce you to the PythonAnywhere crew. I have been to London a couple of times and met with and had coffee with the great folks at PythonAnywhere. They are very good. You're going to use a free account and it's going to stay free. It expires after three months if you don't use it, but if you keep using it, it stays free. And you can upgrade for a more advanced account, but for this class, you just need the completely free account and nothing more. And they don't spam you and they don't try to get your money. They just give it to you for free. So I really like working with them. Once you sign in and you start doing your homework, you're going to be seeing things like these assignments, Initial Database Setup. And when you go in there, pg4e.com is going to give you a database. And these are the connection. The host, the port, the database, and the user, and the password are what you need to make the database connection for Postgres from any client. And you can use any client you want but I'm going to focus on the command-line client. And it just also gives you the exact psql command to type if you have a command-line client. So there's some documentation on how to do what I'm talking about that's available and it's linked right from the lesson. And so you can go through that documentation, but my video is going to show you. So now I have got PythonAnywhere and this is a free account. My username is pg4e. I got it because I got there first. And so there's a number of cool things that you can do here. And the thing we're going to do most, and I tend to open a lot of things in new tabs. So I'm going to open the Consoles screen in a new tab, and I'm going to start a Bash console.
Play video starting at :2:20 and follow transcript2:20
So here I am. I've got a Bash console and it's Linux. There's a number of pwd I can see my current working directory. I can say ls to see files. I already made this file lesson1.sql cat it. cat lesson1.sql. That shows the contents of the text file. Cat README.txt. Oh by the way, I just said cat R-E tab. You can do tab completion when you're typing a filename on a Linux command, which is super cool. The other thing you can do is cursor back through your previous commands. I'm just pressing the up arrow. And so I can do that. I can type cd folder to be in a folder. cd fold tab, that'll work. There's no files in here. I can say cd dot dot, to go up a folder. I can go back into my folder, cd folder tab, and then I say cd tilde. If I say cd squiggle or tilde that goes back to your home folder no matter where you're at. And so you'll see a lot of my commands tell you to do cd tilde and then cd into a subfolder. And everyone has a home directory, like in most commands where there's a folder that you can write to and it's based on the name of your account. And then let's see. We can do a clear command.
Play video starting at :3:48 and follow transcript3:48
OK. So let's run Postgres. That's just Linux. Let's run Postgres. Let me show you one more thing before we go running Postgres. I'm going to go open up another tab of Files. This is super cool. And so here is the text editor. One of the things you might want to do is type some of your SQL into files. This is the text editor. You see we're in our home folder. You see a lot of files with dots. You see the folder that I made. You see a lot of files with dots. So I go into folder. You see that, right? So we see I'm in the folder. I can go back up to my home folder. These dots are like configuration files and folders. Virtual environments if you're doing Python. These are all files. Generally, leave these dot files around and you can see the README.txt that was placed there by them, by PythonAnywhere, when I got first set up. And then lesson1.sql, which is a file that, and I can edit the file and I can save it, okay? And so I'm not going to do that. I'm just going to cancel it and leave. Yeah, I'll leave the page because I don't want to change it. So you can edit these files. You can also edit the files in, oops, come back. Go away. You can use editors like nano or vi. I'm a vi person. And so there we go. So you can edit these files, etc. Let's remember what's inside lesson1.sql because sometimes you might want to do your homework by editing a text file and putting your SQL into it, because you've got to do it over and over again. You make a little tiny mistake. Sometimes I just like cut and paste from my desktop tool into the command line. But here we are. We're in Linux and now we're going to connect to Postgres. So I give you in pretty much every assignment I give you the Postgres command. And so we'll just type it. That's got my account and my database. They're the same thing. You get exactly one account and one database and it's very limited. And then you've got to type the password, but there is this convenient copy button which puts the password in a paste buffer. And I am now logged in. So there I am. Now I'm talking to Postgres. I am running on a, this Postgres client is running in England and it's talking to a server that is in Amazon somewhere owned by the University of Michigan. Okay? So the commands you can type here depend on psql, that is the Postgres command-line client. Some of the commands are that start with a slash, for example, like the dt command. That shows all the tables that you have. That's a psql command. If you're in a different client, you can't always type the dt command. But you can also type SELECT SQL commands, right? SELECT star FROM, I always like to make my pg4e_debug.
Play video starting at :7:12 and follow transcript7:12
So it's going to give me all the rows from the table. Now, this is SQL. You end it with a semicolon and it's SQL. And you're going to learn a lot SQL in this class because that's what this class is about. And there you go. And you see that SQL. You'll see later what the purpose of that is. If you want to run from that file, you type slash i lesson1.sql. And you can run that. That says go run that SQL command or commands from lesson1.sql. And you can also press up arrow here as well and rerun the previous command. And again, I'm not going to do the whole class here. I just wanted to show you how to get in. And now I'm going to show you how to get out. Backslash q. Again, this i, this backslash i, the things that start with a backslash, those are psql commands. They are not SQL commands. This SELECT statement, no matter what client you're using, there'll be a way to send SQL. These are talking to the local client, okay? And if you use some kind of a command line or a full screen, you will see that. So I type backslash q and then I am out of psql and back into Linux. Now, if I go back to Consoles, just leave here, I go back to Consoles, you'll see that I've got this console, so I'm not really logged out. And in the free account, you only get two consoles. So you can come back and you will see when I come back to this console, I'm back where I started. If I want to actually exit out of the console, you can go back to Consoles and you can say get rid of it or from within the console you can type control D or you can type exit. And then it's logged out, so now it's gone. And if you come back here to Consoles, you will see you don't have any consoles. So you'd start another one with Bash. And so again, thanks to the great folks at PythonAnywhere for giving us such a cool way to play with Linux and SQL for this class. And I hope you found this video useful. Cheers.

# Using the DBeaver Client to Run SQL Commands
Hello and welcome to another Postgres for Everybody walkthrough. In this walkthrough, we're going to use instead of PythonAnywhere or a Jupyter Notebook or even the terminal on your own computer and using psql, I'm just going to show you a way to use a sort of high desktop application to work with your SQL database. So I've already installed this DBeaver. And it's free, it's open source, it's quite amazing, and it works pretty well. Not all of these kinds of desktop applications work well with Postgres databases. There is pgAdmin that doesn't work well because your database doesn't have enough power, but DBeaver seems to work out okay. So the way these navigators work is they have what are called connections. And this can do not just Postgres, but as you'll see, a whole bunch of things. You go, you find your way into your assignment, and we're going to do this very first assignment. And I could do this, use this in the database, but psql is a client. We're not going to use that. Our client is going to be DBeaver. So what we're going to do is we're going to go into DBeaver, and we're going to say add another connection and it already knows about Postgres. Now, if you first install it, it may have to install some drivers. Don't worry about it, seems that works just peachy fine, and away you go. You're going to go back now to the data that you've got, and the data that you've got, I'll show that to you in a second, is at pg.pg4e.com. That's the name of the host. The database name, we're going to have to copy and paste that back and forth. Database and the user are the same. So we'll do that and that. So that came from your assignment. Now we can copy our password and come over here, and put our password in, and that's literally all you need to do. And again, we're creating a client through which we can send SQL commands. And so here we go, we've got this. It says this is a database connection, and within that you could have more than one database, but right now we only have one database. And if you keep opening this up, you see that the schemas, these two, the pg_catalog, this has got stuff that Postgres needs and sometimes we'll actually select from that. But don't hurt it. And the information schema, that's like its own internal stuff, leave that alone. The place that you work here is in this public and we're going to be making tables, which currently we have none. And so we want to run some SQL, and so if you have a bunch of these over here on the left-hand side, You want to have this one selected. And then you click on this thing that basically says make a new SQL script. And so this is a script and the destination of the SQL commands is that database. And so if we go back to our assignment now and we look, this CREATE TABLE is the first thing that we're supposed to do. I'll say CREATE TABLE, and then I am going to hit the Go button. That's what this little execute SQL statement is. And look at that. It told us that it worked and now if we pop this open, there's supposed to be a table here. I need to refresh it or something, I'll refresh the connection.
Play video starting at :3:44 and follow transcript3:44
Somehow I lost my connection.
Play video starting at :3:48 and follow transcript3:48
Refresh the connection.
Play video starting at :5:4 and follow transcript5:04
So I refreshed the connection, and then we see the pg4e_debug. So now I'm going to go and do another script. This script is right here. I'll close my little public window there, and I'll go to the next thing I'm supposed to do. I'm going to run another CREATE TABLE pg4e_result and I type that in here and then I run it. Then I go over here and I do a refresh and I see that one. It wouldn't hurt if it auto refreshed. But away we go, we're only going to do a few of these. So then what we're going to do is we've created these two tables and we're going to do Check Answer, which is going to check to see if our tables are created because my autograder is now connecting to that database connection.
Play video starting at :5:55 and follow transcript5:55
And at this point, if we do another refresh, you see that this meta table showed up just like it said it was going to do, and so you've now created this. And so there's things you can do and can't do, and import and export are little bit different. And so most of the assignments you will be able to do in this class using either DBeaver, or another client, or psql. I tend to focus on psql because sometimes you're working on a server and you're logged into that server and you've got to type the commands in command line. So there's nothing wrong with knowing how to use command line, but there's also nothing wrong with knowing how to use a more advanced client. Okay. So that was just a really quick walkthrough on how you might use DBeaver as your client sometimes as a substitute for psql or a compliment to psql. Cheers.   