# Welcome to the Course
Welcome to Course 4 in Postgres for Everybody. Now we're going to finally talk about how things work, and sort of some of the meta issues around databases. And you might say to yourself, why didn't I talk about this at the beginning? In some ways, I did start with history. I started to talk about how standards happen. And really, databases have been a big part of every application that we've built. How they've changed as we and the market and the world has changed. How the Internet changed, how the Cloud happened. And so we're going to start with how they work, how relational databases work. And then we'll talk about what the strengths and the weaknesses are of relational databases and how we build and deploy relational databases and how we make them run at scale. And then again, that scale has changed over the years from 1000 users, hundreds of users to thousands of users to millions of users and on up, billions of users. The NoSQL movement is kind of part of that story. And you might think that the NoSQL movement and the relational database movement are like at odds with one another. And the answer is they're in some ways very complimentary. There are so many moments where the relational databases needed to step up, to up their game a little bit. And NoSQL was a good example of showing a weakness in relational databases. We will talk about deployment. We'll talk about scalability. We'll talk about words like master-master and master-slave replication, etcetera. And how that works and how that impacts performance and what works and what doesn't work. And we'll finish up by actually using a NoSQL database. I've chosen to show you Elasticsearch. It's one of many NoSQL databases where you pretty much talk to it in JSON. The reason I picked Elasticsearch is that it is really common, and has been common for quite some time, to have a hybrid application that uses Elasticsearch to support its search, and then uses a relational database like mySQL or Postgres to do the rest of its application. And so even if you work with relational databases for kind of the rest of your career, it won't be, you shouldn't be surprised if you eventually run into Elasticsearch. So there's a lot of really nice stuff going on in this, and I hope you enjoy the class.

# Lecture: To SQL or to NoSQL?
Hello and welcome to our lecture on database architectures. So if you have taken any classes from me, you've seen this slide whenever I talk about relational databases, whether it's MySQL or SQLite or even Postgres in an earlier class. Every time I give this slide, there's this little part inside of me that like sort of breaks my heart because I'm trying in the beginning to give you a set of rules that are simple and easy to understand, and database normalization is a very hard concept. And so I'm oversimplifying here. This this notion of don't replicate data is most of the time. And the reason I just in the beginning say it's all the time is because most people when they first start out don't need to know that you you can replicate data if you feel like it. Because it's not true. You don't replicate data if you feel like it. But sometimes you are forced by the size of your application and the scale of your application to do the replication. And so it's usually true and I'll honestly say 95 out of 100 times that people say "You know, I'm just going to replicate data," they're doing it for the wrong reason, and that's because they're being lazy and they're not really trying and they don't want to understand data normalization. So don't replicate data until you fully understand database normalization. So a lot of this evolving database architecture is captured in this sort of NoSQL movement. You know, is SQL the right answer or is there something else? Is there something that is better than SQL that's going to be super cool and whatever. And there is so much in technology, this sort of wheel of what's new. Some people like say it's this tech circle where you just rediscover something they did 15 years ago. And so NoSQL in a way is kind of like just storing stuff on disk rather than in a database. Which of course, is also on disk, but storing stuff in files. And honestly, in 1996 we wrote a lot of web applications that did nothing but store everything in files and then we realized they didn't scale for things like transactions and money. And so you just couldn't do it in files because you're rewriting the whole file too often and then you start writing indexing. And then you need transactions. So this NoSQL, in a sense, was a movement that kind of came in 2010, 2013. It says like SQL is bad, it's too constricting. Look at this cool thing I found. And the answer is no, we all found that 20 years ago. And then we decided it wasn't such a bad idea. So this is really not the right question is whether or not SQL is a good idea or not, because SQL is just like a shape. It's a syntax that we use to communicate. A better question, almost, is whether or not it's relational. Is this a set of rows and columns? And again relational, to remember, is at the connection between a row and a column. That's the relationship. Not just rows and columns. That's a spreadsheet is rows and columns. Is it that, or are there a set of documents with key-value pairs in those documents? And that is the non-relational way of thinking about it, that they're not really columns. They're sort of one blob of text. Inside that blob of text, there's a whole bunch of key-value pairs. And these days this isn't even a good sort of way to split the market. Really the way to split the market I think in a healthy way is to use the term ACID or BASE. This is the best question to ask and it is a question that is more about the underlying truth of how databases work and less about the syntax of it or the storage tricks that happen to be used by it. And so this is a nice true technical difference between some of the old traditional databases like Postgres and the new databases like Mongo or Cassandra. And so let's look at the ACID and the BASE acronyms. They're both a little bit contrived, although the ACID is much older. The BASE is sort of like a more recently convenient thing. So ACID stands for Atomicity, Consistency, Isolation, and Durability. It can really be summed up with these databases go to great extents to ensure that if there is some value at a row-column thing that has a 42, and if everyone is simultaneously looking at that, it says 42 no matter who's looking at it. And that's over time. And if it changes, then all of the viewers of that information, so it's simultaneous writers and simultaneous readers. If everyone is trying to write at it and everyone is trying to read at it at a given moment in time, maybe a millisecond later it's different. But at a given moment time, everyone is seeing the same thing, and that's the consistency. When you make a change, it's isolated from the other changes. One writer might set it to 2 and one moment later set it to 4. That's okay, as long as it was 2 and then it was 4, not like 2, 4, 2 for a little while again, 4 a little while, etc. And that's the isolation that everything you do happens, and then when it's done, it's done and it doesn't seem to move backwards in time. Durability just means that it stays there. So BASE, which is the more contrived, it's really eventual consistency is the operative concept here. BASE means like it's pretty much there. You know, it's not as picky as the ACID and state is soft. I don't know. But eventual consistency means that if there is a value somewhere in this blob of stuff of X in it and somebody sets it to 1 and everyone looks at it and it's a 1 and then somebody sets it to 2, for a while, depending on who's looking at it, it might either be a 1 or a 2, but then eventually it's a 2, okay? So if you wait long enough this system will sort of percolate the change from the 1 to the 2 through everywhere and all of the readers will eventually see the 2. It's not that it's not consistent, it's that eventually it's consistent. It's not guaranteed to be consistent. And so you might be a reader and you might say what is it? It's a 1, what is it? It's a 2. And then you might even ask again, what is it, and get a 1. But eventually, after like five minutes, it's a 2, okay? So that's the basic idea. And so here is a diagram of this where we have one writer that this X has a value 42 inside of the black box that is a database. By the way, even though some of you may be colorblind, this is in red and blue for ACID and BASE, but the color doesn't really mean anything, it's just kind of cute. So we've got a value inside of the system of X which has a value, of course, of 42, and then here comes a dog, hi dog. Are you just listening and hearing me give lectures and so you decide to come in? Okay, you can lay down there for a while. Sorry, that was my dog. Hey Shelby, how are you doing? I have to put a picture in of you, how cute you are. So I start giving a lecture and the dog decides to come in. And so here we go, we've got one writer that's going to set it to 10 and one's going to set it to 20 simultaneously, meaning they're just racing towards this data. And you've got a set of readers that are asking what is the current value of X? And they're seeing 42 at this point. The writers have not done anything. And so what happens at some point is the database decides, probably by arrival or anything. It doesn't matter, because these two things don't know what time it is. But at some point it picks something and it says okay, this transaction is going to happen. And while it's making those changes, and to the extent where it has to inform all the readers, it says I'm blocking the X equals 10 for as long as it's going to take until everyone who reads it's going to see a 20, meaning that you're watching it and it's 10, 10, I mean 42, 42, 42, 20 and it stays 20, 20, 20, 20, 20. It doesn't go 42, 20, 42, 20. It's consistent. When it changes to 20, it changes to 20 and doesn't bounce back and forth. And then once that is finished, it's not like we're prohibiting it from ever being changed again. We just then let that one through and then the readers whatever it has to do so that everyone sees it 20, 20, 20, 20, 10, 10, 10, 10 10, not 20, 10, 20, 10. Okay, so you get it? So that's ACID, and it's all about sort of like setting this barrier and stopping transactions from coming in once a transaction is made it into kind of the inner circle of this thing and putting up this little wall that stops things from coming in. The key to BASE, or eventual consistency systems, is they are much more scalable because they spread the data out using many copies, right? They are replicated and this is the old don't replicate, the whole idea of don't replicate is so that that ACID can work, right? So if you have one number, it's really one place in the database and it's not 42 places. But if you have multiple servers, you could have a thousand different servers and have a thousand copies of X. And then your readers can like just like read willy-nilly, right? Your readers can read willy-nilly. So the thing we've introduced here in this BASE style is we have kind of a timestamp. And so we have many copies of X. We have three copies of X of a value 42 at time 0, right? Now the key thing here is this is eventually consistent. X has been 42 for a long time and all the copies of X are 42 and all the copies of X are 42 at time 0. So no matter how many readers you have, you say what's X? They're all going to see 42, okay? They're all going to see 42. The incoming integers are racing. There's multiple writers that are going to try to set X to 10 and set X to 20. Now the key is that in a BASE-style database, any of these systems can be the one that receives the request to change X to 10. And so it changes its copy of X to 10. But it also has to mark the time that it happened because you're going to see because we got racing happening, right? So we set X to 10 and we know that X in this middle system is 10 at time 1. And so if you're asking now, what is X? Well, depending on which of those three systems you see you might see 42 or you might see 10 or you might see 42. And if you ask again, if you keep asking and we've sort of stopped this in time, you might see oh, it's 42. Oh, let us ask again, it's 10. Oh, no, it's not. I ask again, it's 42. So this is the inconsistent moment where depending on the reader, the same reader. Now, if it's kind of cached and sticky and all that you might see it not change. But the point is you technically could see in the outside world of watching, X is either 42 or 10. And the 42 ones don't know that they're invalid at this point. Now, they're like if there was a cache there'd be invalidation, we can't afford that kind of coordination at this point. We can't get them all simultaneously to change because there's 10,000 of them, right? They're all over the Internet and there's 10,000 of them. We'll get there. So at this point X is an inconsistent state. Different viewers will see different values of X. One viewer can see X flipping back and forth between two values. And then the next thing that happens is actually before anything else happens, X equals 20 finds its way to another server. And it's not going to that same server because there's 10,000 of them. And so the second server, the third server at the bottom now has X with a value of 20 at time 2. Now, we're done here. And so the problem is is that if you're a viewer you might see 42 or 10 or 20. And a single viewer might see it sort of flipping between 10, 20, and 42. You're just like what is it? It's 42, it's 10, it's 20, it's 42, it's 10, it's 20, it can go back and forth. Because again the routing of the read request might go to any of these three while it's in this inconsistent state. We've paused it and it's in an inconsistent state and away we go. But we've got to fix it because we do have to have eventual consistency. So more time passes and the middle server says, you know what? I'm going to start telling everybody about my great news that I have a new value for X at time 1, and it sends it to the bottom server. And it's like sorry, Mr. Middle Server, we have a time 2 value, so you're no good. So we'll just throw away your requested update. It's like, oh, okay. And at this point again, we have three possible values of X at any given moment. And then the middle server decides to talk to the server which had a 42 at time 0 and it's like yeah, 10 at time 1 is way better than 42. So it's getting less inconsistent in that you can only see the value at this moment of 10 and 20. And of course, you can guess what's going to happen is that the bottom one wakes up and decides time to forward all my data to all my 10,000 closest friends connected on the Internet. So it goes to the first one, which has got 10 at 1. It's like well, 20 at 2 is better because it's later. And that one updates it. And we still are inconsistent. And now we communicate between the third server and the second server in all of the data and this happens 10,000 times or whatever. And so this is eventually consistent. Now, for now from time going forward no matter how many times you ask and no matter how many servers you end up touching in the asking, X is now 20 and it's going to stay 20. And so the question really is how long did it take while the value of X was inconsistent? And so you can kind of say, really? Is that the big deal if it's going to take a half a second or five seconds or ten seconds? Do we really care? And what if your data is so widely spread that it's not just an X. It's like a 100,000 Xs and everyone is looking at different ones. So eventual consistency is not entirely all bad. It is bad if it's a bank, right? Because eventually something bad is going to happen, right? So it is bad for a bank. So database software basically works hard to meet sort of its semantic rules. So you have this Atomic, right? Which in a moment in time it's always consistent. Things like Oracle, Postgres, MySQL, SQLite or SQLServer all kind of classic ACID-based. And then the eventual consistency are things like Mongo, Casandra, and Google's BigTable and many others, right? And so basically this is the compromise. And the idea is that you can scale these BASE systems far higher, especially within read mostly. And literally almost all database work is read mostly, although we'll talk a bit about sort of writes as much if not more as than reads. Sometimes those databases are a little bit different. And so it seems like it's a pretty small compromise, but when you're dealing with like membership in classes and grades and money and stuff like that it actually is a big deal. And it turns out you spend way too much time in the application recovering from possible errors that are actually rare in BASE-style systems, but you've still got to go like hmm, I just created a new account at csev@umich.edu. Okay, hang on, let's wait a second. And this is actually kind of cool like in account creation when you say I'd like to make a new account, what's the first thing they do? They send you an email to verify your account. So your account actually is not even made yet and what happens is think about what happens is if you asked to make an account in one browser with this one email address, then make the account in another browser and email address, and then you get these emails and you click. So that's the kind of thing to think about about consistency. Now, most systems when they do new accounts will have a little relational database just for new account creation, even if they are fully NoSQL/BASE, that kind of a system. So there are some compromises. One of the primary cool features of ACID-style databases is SERIAL INTEGER keys, but you don't do that. In BASE style you actually generate what's called a Global Unique Identifier that's a combination of random numbers and the current time that are carefully constructed to be global. And then that becomes kind of your primary key. They're longer, but they're not terrible. Like in Postgres, there's a pretty efficient storage for GUIDs. Transactions ensure that on an ACID-based database that you're not getting stale data. And you just have to have retry loops in your application in case there might be stale data and deal with the fact that you've got two new account requests from the same person because they talked to different servers when they started. UNIQUE constraints are difficult. Again, in an ACID database, you could say insert csev on conflict, do nothing, or on conflict, ignore, on conflict, update. So that's when UNIQUE Constraints are triggering. In BASE you got none, because you just don't know. You're talking to one of 10,000 servers and there's no way for them to contact all of the other ones. You have to insert it and then find a way to recover when you turned out to have inserted the same record. There's no uniqueness. And one of the things we do when we're dealing with ACID databases is we build beautiful queries. We join a bunch of things, we sort of give this beautiful query. we hand tune it, we optimize it, we get the index just right and then we get a little tiny bit of data back and it's exactly the data that we want. You tend to sort of like say, you know what? I got 10,000 servers, let's just hit them all and see what happens and then throw away the stuff we don't want. And we'll see sort of applications that use this type of BASE eventual consistency system with a bunch of retrieve and throw away methodology. So the next thing I want to talk about is the difficulty of scaling relational databases and why it is that we turned to something else as we tried to scale relational databases probably starting 20 years ago.

# Scaling Relational Databases
So now I want to answer the question, why not use ACID for everything? I mean, it's so perfect, it's so consistent, and it's so amazing as I've told you in so many previous lectures. Why did we even look at BASE? And the key is that it was difficult to scale databases. And so there's a couple of different ways to scale databases and we'll go through them. One is what we call vertical scaling and that's just throwing more hardware at the problem. More drives, more spinning disks, more channels, more external ports. If you have one port and 50 disks, it doesn't do you any good. But if you have 50 ports and 50 disks, things like RAID arrays, like RAID 0 and RAID 1. The idea was to just find ways to increase the simultaneous bandwidth that we could get from disk drives. And mostly because what databases are doing is scanning and discarding data to produce a small data set to give you back, a small result set to give you back, more CPUs and more memory. So the more you can keep of your database in cache and ACID-style databases are great at using memory very well. So you start with 8 gig, then 16 gig and 32 gig and 64 gig, and everything's better until you then hit that new limit. So you're just like that was great and we're super fast. Oh,wait a sec. It's a year later or six months later and now you need 128. So you can't just throw more disk drive, more processors, and more memory. And especially in 2010, 2011, as we were moving from buying our own expensive hardware to virtualization, it was really difficult to virtualize large memory and many processors. And so we tended to virtualize small boxes. So if you wanted a big box with 8 CPUs and 32 gig of RAM because you needed it, you tended to have to do something like either buy it and put it somewhere, lease space. Or you had to lease it and you had to make like a three-year commitment because that was a pretty expensive, $40,000 piece of hardware. And you needed that hardware because of your database. Another thing for vertical scaling that there was a couple of years where how do you do your database tuning? Well, they switched to solid state disk drives, and like I'm a genius. And the answer is yeah, that was a genius move for a while. And actually SSDs when they first came out were great because their random access from place to place is fixed because they don't have to have rotational delays like disk drives do. But then it got even better because now if you're reading a bunch of tiny little blocks, you can actually send a thing to an SSD that says since it's like a scatter gather, read this, this, this. Here's 32 blocks I want you to read, read them all, and then just tell me when you got them and then they just start coming back at you. And vertical scaling has been great. But vertical scaling is never enough, right? We never have enough. And so we've got to find ways to tune. And so one of the classic ways of tuning a relational database is to add what are called read-only replicas. And you basically have some kind of software, maybe even a database itself, that looks at each of the SQL statements. Some of them are not making any changes to data and some of them are. So an insert, or an update, or a begin transaction or something like that. And you look at that you go, we're going to have one master database. And that's a traditional vertically scaled database. We make it as fast as we can. And we're going to take transactions that either are going to require statements that require a transaction or are going to change the database, and we route that to the master database server. And then as changes are made, it spews out a transaction log. Transaction logs are how databases ensure that changes are made. They write it to the transaction log, then they write it to the actual database. And if something blows up in the middle they go back and look the transaction log and they reapply. That's what transaction logs are for. But you can have a number of other servers that are watching those transaction logs, and then having a replica of the database and every time they see a transaction, then they add it to the replica. And so this actually is kind of BASE-like eventual consistency. Now, these are delayed by maybe a quarter of a second or even less depending on how awesome they are and how fast the network is and how fast the servers are. So you could think of this as adding sort of BASE-like read stuff to an otherwise ACID database. And then you know things like basic counts and selects and joins and transactions that you know have no chance of modifying the database, you send those to the replicas. And so you could have as many replicas as you want. You've got to be careful because at some point you can't have 1,000 replicas hitting some poor transaction log because there's still only one transaction log. But the idea of read-only replicas released the need to completely scale the master database for the reads. And there could be brief moments of inconsistency. But away you go. And now in a way, we'll see how this becomes kind of a modern hybrid architecture, because this is already a blend of ACID and BASE, because these replicas are ever so slightly potentially inconsistent. Multi-master is another kind of thing where you have two master databases but because the master database has the responsibility of sort of putting a block on all transactions on the way until the transaction in flight really completes, there's a lot of coordination between the masters. And so people have this, but it's really a compromise because the need to send every lock and every row and everything that might modify to all of them to say here comes X. I just got a thing to X and you've got to stop all Xs so that combination of two master databases has got to be able to coordinate well enough to make it from the outside world you can't ever have inconsistency. Now of course you can have this multi-master and now each master has a transaction log and they've got to talk to each other's transaction logs and they got to read replicas. So multi-master is something that people have used at times, but usually it's not a really good solution because of so much coordination between the masters. At some point, it's better just to have a bigger master. The other common thing is multiple store types. So things like profile pictures in a blogging system or an uploaded picture. You know, you don't really want to put that in a database. Databases are fine at storing pictures. They're fine at storing blobs. You can put PDFs or QuickTime movies in a database, but it turns out that it just harms database backups. And so you tend to say, you know what? For the blobs, for the large files that I want to deal with, I'm going to have them on some kind of a shared file system because that's mostly, that's such a read mostly kind of a thing. And so you just kind of have a hybrid where you just say, I'm going to have a database table called the where are the files and then I'm going to have a file system that has files. And in the example I'm using you're seeing sort of hashed names. It's common to come up with what's called a single instance data store where you actually read the entire file and come up with a SHA-1 or some other hash of the file and use that as the index. And then you can actually have multiple virtual files in your relational database that point to the same physical file. But then when you're actually going to serve the physical file, like a QuickTime movie or a PDF or a JPEG, you just use the standard open. You open it, you read it, and you send the bytes out to the browser or whatever it is. Now you're deciding how to store all this stuff inside your application. There's no SQL that kind of figures this out that, that automatically says it's a big blob so I'm going to do it completely differently. ACID databases do often store it differently. The problem is things like backup can be problematic, and so it's nice to have, with this kind of a multiple store type it's nice to have an independent backup between your relational system and your file system just because especially if you're storing your files based on some kind of a hash. The backup is really beautifully simple for a file system and the backup is a little harder for an ACID-style relational database. So multiple store types. There's also what I'll call a multi-tenant pretend cloud. I'm a cloud vendor, but I really don't have a cloud application. And so what they have is one bunch of application code. And then they have little tiny single-instance relational databases, one for each client. And then they say overall, we've got like 1,000 clients, but you also have like 1,000 databases. And it's not a bad architecture, actually it's a beautiful architecture in that it lets you have a single application for lots of clients. But then the fact that it might have scaled to 10 million, well, no, it just scaled a bunch of different 80,000, how many hundred thousand, it just there's hundred, hundred thousand person things and now it's 10 million, but it's not really 10 million. So I'll call this "pretend cloud". It's not a cloud-scale application. It is just a multi-tenant application that is conveniently architected to look like a cloud application. And so if we look at this, and you look at sort of how applications, let's just imagine email. This is a map of higher education institutions. And so you could think of email, relational databases were really good at handling things between 1,000 and a quarter of a million. And so you could imagine an email system with all the students and the alumni, quarter of a million, half a million, maybe. And so you got a good relational database. You'd buy some hardware and size the hardware for that database. And the database grows slowly because we're only going to pull in 15,000 new students a year, so life was good, right, because these are all separate databases. And in that kind of fake cloud where they're all separate databases, they're all the same. These might all be customers of one company, one cloud vendor of email, but really there's just one database for each of these and they've still got a quarter of a million or less folks. And this is the world in which ACID-based relational databases evolved, is handling let's just say a quarter of a million or less. A quarter of a million was a big instance, right? But if you could handle a quarter of a million, like Oracle and Postgres and MySQL, then we can use you for the kind of thing, because we had all these separate little databases. And so that's the state of databases in 2002. And up next we're going to talk about like what disrupted this and that is the first generation real cloud applications.

# 